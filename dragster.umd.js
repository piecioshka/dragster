(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./ts/dragster.script.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./ts/dragster.script.ts":
/*!*******************************!*\
  !*** ./ts/dragster.script.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst enums_1 = __webpack_require__(/*! ./enums */ \"./ts/enums.ts\");\nconst dummyCallback = () => { };\nconst CLASS_DRAGGING = 'is-dragging';\nconst CLASS_DRAGOVER = 'is-drag-over';\nconst CLASS_DRAGGABLE = 'dragster-draggable';\nconst CLASS_REGION = 'dragster-drag-region';\nconst CLASS_PLACEHOLDER = 'dragster-drop-placeholder';\nconst CLASS_TEMP_ELEMENT = 'dragster-temp';\nconst CLASS_TEMP_CONTAINER = 'dragster-temp-container';\nconst CLASS_HIDDEN = 'dragster-is-hidden';\nconst CLASS_REPLACABLE = 'dragster-replacable';\nexports.Dragster = function ({ elementSelector = '.dragster-block', regionSelector = '.dragster-region', dragHandleCssClass = false, dragOnlyRegionCssClass = 'dragster-region--drag-only', replaceElements = false, updateRegionsHeight = true, minimumRegionHeight = 60, onBeforeDragStart = dummyCallback, onAfterDragStart = dummyCallback, onBeforeDragMove = dummyCallback, onAfterDragMove = dummyCallback, onBeforeDragEnd = dummyCallback, onAfterDragEnd = dummyCallback, onAfterDragDrop = dummyCallback, scrollWindowOnDrag = false, cloneElements = false, wrapDraggableElements = true, shadowElementUnderMouse = false, }) {\n    const dragsterId = Math.floor((1 + Math.random()) * 0x10000).toString(16);\n    const getElement = (element, callback) => {\n        const parent = element.parentNode;\n        if (!parent ||\n            (element.classList &&\n                element.classList.contains(CLASS_REGION) &&\n                !element.classList.contains(dragOnlyRegionCssClass))) {\n            return;\n        }\n        if (callback(element)) {\n            return element;\n        }\n        return callback(parent) ? parent : getElement(parent, callback);\n    };\n    const createElement = (classnames) => {\n        const elementAfter = document.createElement('div');\n        elementAfter.classList.add(...classnames);\n        elementAfter.dataset.dragsterId = dragsterId;\n        return elementAfter;\n    };\n    const insertAfter = (elementTarget, elementAfter) => {\n        if (elementTarget && elementTarget.parentNode) {\n            const refChild = wrapDraggableElements\n                ? elementTarget\n                : elementTarget.nextSibling;\n            elementTarget.parentNode.insertBefore(elementAfter, refChild);\n        }\n    };\n    const insertBefore = (elementTarget, elementBefore) => {\n        if (elementTarget && elementTarget.parentNode) {\n            elementTarget.parentNode.insertBefore(elementBefore, elementTarget);\n        }\n    };\n    const createElementWrapper = () => createElement([CLASS_DRAGGABLE]);\n    const createShadowElement = () => {\n        const element = createElement([CLASS_TEMP_ELEMENT, CLASS_HIDDEN]);\n        element.style.position = 'fixed';\n        document.body.appendChild(element);\n        return element;\n    };\n    const createPlaceholder = () => createElement([CLASS_PLACEHOLDER]);\n    const removeElements = (selector) => {\n        const elements = [\n            ...document.getElementsByClassName(selector),\n        ];\n        elements.forEach((element) => {\n            if (element.dataset.dragsterId !== dragsterId) {\n                return;\n            }\n            element.parentNode.removeChild(element);\n        });\n    };\n    const cleanWorkspace = ({ element, eventName, regions, }) => {\n        if (eventName) {\n            regions.forEach(function (region) {\n                region.removeEventListener(eventName, regionEventHandlers.mousemove);\n            });\n            document.body.removeEventListener(eventName, regionEventHandlers.mousemove);\n        }\n        if (element) {\n            element.classList.remove(CLASS_DRAGGING);\n        }\n        [...document.getElementsByClassName(CLASS_DRAGGABLE)].forEach((dragEl) => {\n            if (!dragEl.firstChild) {\n                dragEl.parentNode.removeChild(dragEl);\n            }\n        });\n        removeElements(CLASS_PLACEHOLDER);\n        removeElements(CLASS_TEMP_ELEMENT);\n        fnUpdateRegionsHeight();\n    };\n    const cleanReplacables = () => {\n        [...document.getElementsByClassName(CLASS_REPLACABLE)].forEach((elem) => elem.classList.remove(CLASS_REPLACABLE));\n    };\n    const findDraggableElements = () => [...document.querySelectorAll(elementSelector)];\n    const findRegionElements = () => [...document.querySelectorAll(regionSelector)];\n    const fnWrapDraggableElements = (elements) => {\n        if (wrapDraggableElements === false) {\n            console.warn('You have disabled the default behavior of wrapping the draggable elements. ' +\n                'If you want Dragster.js to work properly you still will have to do this manually.\\n' +\n                '\\n' +\n                'More info: https://github.com/sunpietro/dragster/blob/master/README.md#user-content-wrapdraggableelements---boolean');\n            return;\n        }\n        elements.forEach((draggableElement) => {\n            const draggableParent = draggableElement.parentNode;\n            if (draggableParent.classList.contains(CLASS_DRAGGABLE)) {\n                return;\n            }\n            const wrapper = createElementWrapper();\n            draggableParent.insertBefore(wrapper, draggableElement);\n            draggableParent.removeChild(draggableElement);\n            wrapper.appendChild(draggableElement);\n        });\n    };\n    const fnUpdateRegionsHeight = () => {\n        if (!updateRegionsHeight) {\n            return;\n        }\n        const regions = [\n            ...document.getElementsByClassName(CLASS_REGION),\n        ];\n        regions.forEach((region) => {\n            const elements = [\n                ...region.querySelectorAll(elementSelector),\n            ];\n            if (!elements.length) {\n                return;\n            }\n            let regionHeight = minimumRegionHeight;\n            elements.forEach((element) => {\n                const styles = window.getComputedStyle(element);\n                regionHeight +=\n                    element.offsetHeight +\n                        parseInt(styles.marginTop, 10) +\n                        parseInt(styles.marginBottom, 10);\n            });\n            region.style.height = regionHeight + 'px';\n        });\n    };\n    const isDraggableCallback = (element) => element.classList &&\n        element.classList.contains(CLASS_DRAGGABLE) &&\n        element.dataset.dragsterId === dragsterId;\n    const isInDragOnlyRegionCallback = (element) => element.classList && element.classList.contains(dragOnlyRegionCssClass);\n    const resetDragsterWorkspace = (moveEvent, upEvent, regions) => {\n        cleanWorkspace({ element: draggedElement, eventName: moveEvent, regions });\n        cleanWorkspace({ element: draggedElement, eventName: upEvent, regions });\n    };\n    const scrollWindow = (event) => {\n        const { changedTouches } = event;\n        const positionY = (changedTouches ? changedTouches[0] : event).clientY;\n        const diffSize = 60;\n        if (windowHeight - positionY < diffSize) {\n            window.scrollBy(0, 10);\n        }\n        else if (positionY < diffSize) {\n            window.scrollBy(0, -10);\n        }\n    };\n    const discoverWindowHeight = () => {\n        windowHeight = window.innerHeight;\n    };\n    const addEventListenersToRegions = (regions) => {\n        regions.forEach((region) => {\n            region.classList.add(CLASS_REGION);\n            region.dataset.dragsterId = dragsterId;\n            region.addEventListener(enums_1.EDomEvent.MOUSEDOWN, regionEventHandlers.mousedown, false);\n            region.addEventListener(enums_1.EDomEvent.TOUCHSTART, regionEventHandlers.mousedown, false);\n        });\n    };\n    let visiblePlaceholder = {\n        top: false,\n        bottom: false,\n    };\n    let dragsterEventInfo;\n    let shadowElement;\n    let shadowElementRegion;\n    let draggedElement;\n    let regionEventHandlers;\n    let hideShadowElementTimeout;\n    let dropActions;\n    let moveActions;\n    let shadowElementPositionXDiff;\n    let shadowElementPositionYDiff;\n    let windowHeight = window.innerHeight;\n    let draggableElements = findDraggableElements();\n    let regions = findRegionElements();\n    if (replaceElements) {\n        document.body.appendChild(createElement([CLASS_HIDDEN, CLASS_TEMP_CONTAINER]));\n    }\n    regionEventHandlers = {\n        mousedown: (event) => {\n            const { which: keyId, changedTouches, type } = event;\n            const target = event.target;\n            if (dragHandleCssClass &&\n                (typeof dragHandleCssClass !== 'string' ||\n                    !target.classList.contains(dragHandleCssClass))) {\n                return;\n            }\n            if (onBeforeDragStart(event) === false ||\n                keyId === 3) {\n                return;\n            }\n            event.preventDefault();\n            draggedElement = getElement(target, isDraggableCallback);\n            if (!draggedElement) {\n                return;\n            }\n            const isTouch = type === enums_1.EDomEvent.TOUCHSTART;\n            const eventObject = changedTouches ? changedTouches[0] : event;\n            const moveEvent = isTouch ? enums_1.EDomEvent.TOUCHMOVE : enums_1.EDomEvent.MOUSEMOVE;\n            const upEvent = isTouch ? enums_1.EDomEvent.TOUCHEND : enums_1.EDomEvent.MOUSEUP;\n            const { mousemove, mouseup } = regionEventHandlers;\n            regions.forEach((region) => {\n                region.addEventListener(moveEvent, mousemove, false);\n                region.addEventListener(upEvent, mouseup, false);\n            });\n            document.body.addEventListener(moveEvent, mousemove, false);\n            document.body.addEventListener(upEvent, mouseup, false);\n            const targetRegion = draggedElement.getBoundingClientRect();\n            shadowElementPositionXDiff = targetRegion.left - eventObject.clientX;\n            shadowElementPositionYDiff = targetRegion.top - eventObject.clientY;\n            shadowElement = createShadowElement();\n            shadowElement.innerHTML = draggedElement.innerHTML;\n            shadowElement.style.width = targetRegion.width + 'px';\n            shadowElement.style.height = targetRegion.height + 'px';\n            shadowElement.dataset.dragsterId = dragsterId;\n            shadowElementRegion = shadowElement.getBoundingClientRect();\n            draggedElement.classList.add(CLASS_DRAGGING);\n            dragsterEventInfo = {\n                drag: { node: draggedElement },\n                drop: { node: null },\n                shadow: { node: shadowElement, top: null, left: null },\n                placeholder: { node: null, position: null },\n                dropped: null,\n                clonedFrom: null,\n                clonedTo: null,\n            };\n            event.dragster = dragsterEventInfo;\n            onAfterDragStart(event);\n        },\n        mousemove: (event) => {\n            event.dragster = dragsterEventInfo;\n            if (onBeforeDragMove(event) === false || !shadowElementRegion) {\n                return;\n            }\n            event.preventDefault();\n            const eventObject = (event.changedTouches\n                ? event.changedTouches.item(0)\n                : event);\n            const { view, clientX, clientY } = eventObject;\n            const pageXOffset = view ? view.pageXOffset : 0;\n            const pageYOffset = view ? view.pageYOffset : 0;\n            const elementPositionY = clientY + pageYOffset;\n            const elementPositionX = clientX + pageXOffset;\n            const unknownTarget = document.elementFromPoint(clientX, clientY);\n            const dropTarget = getElement(unknownTarget, isDraggableCallback);\n            const top = shadowElementUnderMouse\n                ? clientY + shadowElementPositionYDiff\n                : clientY;\n            const left = shadowElementUnderMouse\n                ? elementPositionX + shadowElementPositionXDiff\n                : elementPositionX - shadowElementRegion.width / 2;\n            const isDragNodeAvailable = dragsterEventInfo.drag.node && dragsterEventInfo.drag.node.dataset;\n            const isInDragOnlyRegion = !!(dropTarget && getElement(dropTarget, isInDragOnlyRegionCallback));\n            const isAllowedTarget = unknownTarget.dataset.dragsterId === dragsterId;\n            const isTargetRegion = unknownTarget.classList.contains(CLASS_REGION) && isAllowedTarget;\n            const isTargetRegionDragOnly = unknownTarget.classList.contains(dragOnlyRegionCssClass) &&\n                isAllowedTarget;\n            const isTargetPlaceholder = unknownTarget.classList.contains(CLASS_PLACEHOLDER);\n            const hasTargetDraggaBleElements = unknownTarget.getElementsByClassName(CLASS_DRAGGABLE).length > 0;\n            const hasTargetPlaceholders = unknownTarget.getElementsByClassName(CLASS_PLACEHOLDER).length > 0;\n            clearTimeout(hideShadowElementTimeout);\n            shadowElement.style.top = top + 'px';\n            shadowElement.style.left = left + 'px';\n            shadowElement.classList.remove(CLASS_HIDDEN);\n            dragsterEventInfo.shadow.top = top;\n            dragsterEventInfo.shadow.left = left;\n            const cannotBeDropped = !isDragNodeAvailable && !isTargetRegion && !isTargetPlaceholder;\n            const isNotDragOnlyDropTarget = dropTarget && dropTarget !== draggedElement && !isInDragOnlyRegion;\n            const isEmptyDropTargetWithoutPlaceholder = isTargetRegion &&\n                !isTargetRegionDragOnly &&\n                !hasTargetDraggaBleElements &&\n                !hasTargetPlaceholders;\n            const isNotEmptyDropTargetWithoutPlaceholder = isTargetRegion &&\n                !isTargetRegionDragOnly &&\n                hasTargetDraggaBleElements &&\n                !hasTargetPlaceholders;\n            if (cannotBeDropped) {\n                moveActions.removePlaceholders();\n            }\n            else if (isNotDragOnlyDropTarget) {\n                moveActions.removePlaceholders();\n                moveActions.addPlaceholderOnTarget(dropTarget, elementPositionY, pageYOffset);\n            }\n            else if (isEmptyDropTargetWithoutPlaceholder) {\n                moveActions.removePlaceholders();\n                moveActions.addPlaceholderInRegion(unknownTarget);\n            }\n            else if (isNotEmptyDropTargetWithoutPlaceholder) {\n                moveActions.removePlaceholders();\n                moveActions.addPlaceholderInRegionBelowTargets(unknownTarget);\n            }\n            if (scrollWindowOnDrag) {\n                scrollWindow(event);\n            }\n            fnUpdateRegionsHeight();\n            onAfterDragMove(event);\n        },\n        mouseup: (event) => {\n            event.dragster = dragsterEventInfo;\n            const isTouch = event.type === enums_1.EDomEvent.TOUCHSTART;\n            const moveEvent = isTouch ? enums_1.EDomEvent.TOUCHMOVE : enums_1.EDomEvent.MOUSEMOVE;\n            const upEvent = isTouch ? enums_1.EDomEvent.TOUCHEND : enums_1.EDomEvent.MOUSEUP;\n            if (onBeforeDragEnd(event) === false) {\n                resetDragsterWorkspace(moveEvent, upEvent, regions);\n                return;\n            }\n            const findByClass = replaceElements\n                ? CLASS_REPLACABLE\n                : CLASS_PLACEHOLDER;\n            const dropTarget = document.getElementsByClassName(findByClass)[0];\n            const isFromDragOnlyRegion = !!(draggedElement && getElement(draggedElement, isInDragOnlyRegionCallback));\n            const canBeCloned = cloneElements && isFromDragOnlyRegion;\n            hideShadowElementTimeout = setTimeout(() => resetDragsterWorkspace(moveEvent, upEvent, regions), 200);\n            cleanReplacables();\n            if (!draggedElement || !dropTarget) {\n                resetDragsterWorkspace(moveEvent, upEvent, regions);\n                return;\n            }\n            let dropDraggableTarget = getElement(dropTarget, isDraggableCallback);\n            dropDraggableTarget = dropDraggableTarget || dropTarget;\n            if (draggedElement !== dropDraggableTarget) {\n                if (!replaceElements && !canBeCloned) {\n                    event.dragster = dropActions.moveElement(event.dragster, dropTarget, dropDraggableTarget);\n                    onAfterDragDrop(event);\n                }\n                else if (replaceElements && !canBeCloned) {\n                    event.dragster = dropActions.replaceElements(event.dragster, dropDraggableTarget);\n                    onAfterDragDrop(event);\n                }\n                else if (!replaceElements && canBeCloned) {\n                    event.dragster = dropActions.cloneElements(event.dragster, dropTarget, dropDraggableTarget);\n                    onAfterDragDrop(event);\n                }\n                dropDraggableTarget.classList.remove(CLASS_DRAGOVER);\n            }\n            resetDragsterWorkspace(moveEvent, upEvent, regions);\n            onAfterDragEnd(event);\n        },\n    };\n    moveActions = {\n        addPlaceholderOnTarget: (dropTarget, elementPositionY, pageYOffset) => {\n            const dropTargetRegion = dropTarget.getBoundingClientRect();\n            const placeholder = createPlaceholder();\n            const maxDistance = dropTargetRegion.height / 2;\n            cleanReplacables();\n            if (!replaceElements) {\n                if (elementPositionY - pageYOffset - dropTargetRegion.top < maxDistance &&\n                    !visiblePlaceholder.top) {\n                    removeElements(CLASS_PLACEHOLDER);\n                    placeholder.dataset.placeholderPosition = enums_1.EVisualPosition.TOP;\n                    insertBefore(dropTarget.firstChild, placeholder);\n                    dragsterEventInfo.placeholder.position = enums_1.EVisualPosition.TOP;\n                }\n                else if (dropTargetRegion.bottom - (elementPositionY - pageYOffset) <\n                    maxDistance &&\n                    !visiblePlaceholder.bottom) {\n                    removeElements(CLASS_PLACEHOLDER);\n                    placeholder.dataset.placeholderPosition = enums_1.EVisualPosition.BOTTOM;\n                    dropTarget.appendChild(placeholder);\n                    dragsterEventInfo.placeholder.position = enums_1.EVisualPosition.BOTTOM;\n                }\n            }\n            else {\n                dropTarget.classList.add(CLASS_REPLACABLE);\n            }\n            dragsterEventInfo.placeholder.node = placeholder;\n            dragsterEventInfo.drop.node = dropTarget;\n        },\n        addPlaceholderInRegion: (regionTarget) => {\n            const placeholder = createPlaceholder();\n            regionTarget.appendChild(placeholder);\n            dragsterEventInfo.placeholder.position = enums_1.EVisualPosition.BOTTOM;\n            dragsterEventInfo.placeholder.node = placeholder;\n            dragsterEventInfo.drop.node = regionTarget;\n        },\n        addPlaceholderInRegionBelowTargets: (regionTarget) => {\n            const elementsInRegion = [\n                ...regionTarget.getElementsByClassName(CLASS_DRAGGABLE),\n            ];\n            const filteredElements = elementsInRegion.filter((elementInRegion) => elementInRegion.dataset.dragsterId === dragsterId);\n            const dropTarget = filteredElements[filteredElements.length - 1];\n            const placeholder = createPlaceholder();\n            placeholder.dataset.placeholderPosition = enums_1.EVisualPosition.BOTTOM;\n            removeElements(CLASS_PLACEHOLDER);\n            dropTarget.appendChild(placeholder);\n            dragsterEventInfo.placeholder.position = enums_1.EVisualPosition.BOTTOM;\n            dragsterEventInfo.placeholder.node = placeholder;\n            dragsterEventInfo.drop.node = dropTarget;\n        },\n        removePlaceholders: () => {\n            if (!replaceElements) {\n                removeElements(CLASS_PLACEHOLDER);\n            }\n            else {\n                cleanReplacables();\n            }\n        },\n    };\n    dropActions = {\n        moveElement: (dragsterEvent, dropTarget, dropDraggableTarget) => {\n            const dropTemp = wrapDraggableElements === false\n                ? draggedElement\n                : createElementWrapper();\n            const placeholderPosition = dropTarget.dataset.placeholderPosition;\n            if (placeholderPosition === enums_1.EVisualPosition.TOP) {\n                insertBefore(dropDraggableTarget, dropTemp);\n            }\n            else {\n                if (wrapDraggableElements === false) {\n                    insertAfter(dropTemp, dropDraggableTarget);\n                }\n                else {\n                    insertAfter(dropDraggableTarget, dropTemp);\n                }\n            }\n            if (draggedElement.firstChild && wrapDraggableElements === true) {\n                dropTemp.appendChild(draggedElement.firstChild);\n            }\n            dragsterEvent.dropped = dropTemp;\n            return dragsterEvent;\n        },\n        replaceElements: (dragsterEvent, dropDraggableTarget) => {\n            const dropTemp = document.getElementsByClassName(CLASS_TEMP_CONTAINER)[0];\n            dropTemp.innerHTML = draggedElement.innerHTML;\n            draggedElement.innerHTML = dropDraggableTarget.innerHTML;\n            dropDraggableTarget.innerHTML = dropTemp.innerHTML;\n            dropTemp.innerHTML = '';\n            dragsterEvent.dropped = dropTemp;\n            return dragsterEvent;\n        },\n        cloneElements: (dragsterEvent, dropTarget, dropDraggableTarget) => {\n            const dropTemp = draggedElement.cloneNode(true);\n            const placeholderPosition = dropTarget.dataset.placeholderPosition;\n            if (placeholderPosition === enums_1.EVisualPosition.TOP) {\n                insertBefore(dropDraggableTarget, dropTemp);\n            }\n            else {\n                insertAfter(dropDraggableTarget, dropTemp);\n            }\n            cleanWorkspace({ element: dropTemp, regions });\n            dragsterEvent.clonedFrom = draggedElement;\n            dragsterEvent.clonedTo = dropTemp;\n            return dragsterEvent;\n        },\n    };\n    fnWrapDraggableElements(draggableElements);\n    addEventListenersToRegions(regions);\n    window.addEventListener('resize', discoverWindowHeight, false);\n    return {\n        update: () => {\n            draggableElements = findDraggableElements();\n            fnWrapDraggableElements(draggableElements);\n            fnUpdateRegionsHeight();\n            discoverWindowHeight();\n        },\n        updateRegions: () => {\n            regions = findRegionElements();\n            addEventListenersToRegions(regions);\n        },\n        destroy: () => {\n            regions.forEach((region) => {\n                region.classList.remove(CLASS_REGION);\n                region.removeEventListener(enums_1.EDomEvent.MOUSEDOWN, regionEventHandlers.mousedown);\n                region.removeEventListener(enums_1.EDomEvent.MOUSEMOVE, regionEventHandlers.mousemove);\n                region.removeEventListener(enums_1.EDomEvent.MOUSEUP, regionEventHandlers.mouseup);\n                region.removeEventListener(enums_1.EDomEvent.TOUCHSTART, regionEventHandlers.mousedown);\n                region.removeEventListener(enums_1.EDomEvent.TOUCHMOVE, regionEventHandlers.mousemove);\n                region.removeEventListener(enums_1.EDomEvent.TOUCHEND, regionEventHandlers.mouseup);\n            });\n            document.body.removeEventListener(enums_1.EDomEvent.MOUSEMOVE, regionEventHandlers.mousemove);\n            document.body.removeEventListener(enums_1.EDomEvent.TOUCHMOVE, regionEventHandlers.mousemove);\n            document.body.removeEventListener(enums_1.EDomEvent.MOUSEUP, regionEventHandlers.mouseup);\n            document.body.removeEventListener(enums_1.EDomEvent.TOUCHEND, regionEventHandlers.mouseup);\n            window.removeEventListener('resize', discoverWindowHeight);\n        },\n    };\n};\n\n\n//# sourceURL=webpack:///./ts/dragster.script.ts?");

/***/ }),

/***/ "./ts/enums.ts":
/*!*********************!*\
  !*** ./ts/enums.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EDomEvent;\n(function (EDomEvent) {\n    EDomEvent[\"TOUCHSTART\"] = \"touchstart\";\n    EDomEvent[\"TOUCHMOVE\"] = \"touchmove\";\n    EDomEvent[\"TOUCHEND\"] = \"touchend\";\n    EDomEvent[\"MOUSEDOWN\"] = \"mousedown\";\n    EDomEvent[\"MOUSEMOVE\"] = \"mousemove\";\n    EDomEvent[\"MOUSEUP\"] = \"mouseup\";\n})(EDomEvent = exports.EDomEvent || (exports.EDomEvent = {}));\nvar EVisualPosition;\n(function (EVisualPosition) {\n    EVisualPosition[\"TOP\"] = \"top\";\n    EVisualPosition[\"BOTTOM\"] = \"bottom\";\n})(EVisualPosition = exports.EVisualPosition || (exports.EVisualPosition = {}));\n\n\n//# sourceURL=webpack:///./ts/enums.ts?");

/***/ })

/******/ });
});